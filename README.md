<details>
  <summary>Много текста</summary>
  ```
  CMake Error at formatter_ex_lib/CMakeLists.txt:8 (add_library): add_library cannot create target "formatter_ex" because another target  with the same name already exists. The existing target is a static library created in source directory       "/home/mocurin/lab03/formatter_ex_lib". See documentation for policy CMP0002 for more details.
  CMake Error at formatter_lib/CMakeLists.txt:8 (add_library): add_library cannot create target "formatter" because another target with the same name already exists. The existing target is a static library created in source directory "/home/mocurin/lab03/formatter_lib". See documentation for policy CMP0002 for more details.
  CMake Error at formatter_ex_lib/CMakeLists.txt:13 (target_link_libraries): Attempt to add link library "formatter" to target "formatter_ex" which is not built in this directory.
  CMake Error at solver_application/CMakeLists.txt:11 (add_executable): add_executable cannot create target "example" because another target with the same name already exists. The existing target is an executable created in source directory "/home/mocurin/lab03/hello_world_application". See documentation for policy CMP0002 for more details.
  CMake Error at solver_application/CMakeLists.txt:13 (target_link_libraries): Attempt to add link library "solver_lib" to target "example" which is not built in this directory.
```
</details>

## Алгоритм прямого поиска
Максимально простой алгоритм поиска подстроки в строке.
Его основная идея заключается в последовательном прогоне подстроки без какой-либо предобработки. Каждый символ строки сравнивается с первым символом подстроки, затем, если символы совпадают запускается цикл последовательно проверяющий оставшиеся символы подстроки и соответствующие символы строки. В случае всех успешных проверок возвращается позиция, на которой запустился второй цикл, в противном случае проверка продолжается с позиции после этой. Если подстрока не была найдена - вернется _"неправильное значение"_, в моем случае это `std::string::npos`.

Блок-схема алгоритма:

![Блок-схема алгоритма](https://raw.githubusercontent.com/mocurin/test/master/pics/Naive_algorithm.svg?sanitize=true)

В _лучшем случае_ время работы алгоритма - **O(N)**, где N - длина строки. Все бы ничего, если бы не время работы в _худшем случае_ - **O(N*M)**, где M - длина подстроки. Причиной тому служат многократные прогоны одной и той же позиции в строке, ведь уже проверенные позиции никак не помечаются и не пропускаются

Плюсы:

 - Исключительная простота написания
 - Малое выделение памяти (нужно всего 2 счетчика и опционально две переменных, отражающих длину строки и подстроки)

Минусы:
 - Большое время работы на определенных данных
 
## Алгоритм Рабина-Карпа
Алгоритм, смысл которого заключается в использовании _хеширования_.
Сначала вычисляется хеш подстроки и первых элементов строки, в которой производится поиск, затем хеши сравниваются. Если хеши совпадают - начинается посимвольная проверка, в противном случае из старого хеша считается новый, для следующей подстроки, и хеши снова сравниваются.

В то время как алгоритм хеширования может быть любым кольцевым хешем, наилучшим выбором будет именно **полиномиальный хеш**, чьим преимуществом является относительно низкая вероятность коллизий и быстрый пересчет хеша последовательных подстрок. Как раз его изначально предлагали Рабин и Карп.
Короче говоря, строка представляется как полином с основанием _X_ (в идеале - случайное число от 2 до Q, я же брал размер алфавита) и на каждом действии (дабы не переполнить тип) получившееся число берется по модулю _Q_ (какое-то простое число). Ключевой особенностью этого хеша является его пересчет - нужно всего лишь вычесть первый элемент подстроки, умноженный на наибольшую степень *Х*, домножить на *Х* и прибавить добавленный элемент (по факту, домноженный на *Х^0^*). И не забыть взять по модулю, а то мало ли чего. Кстати, где-то тут возникает потребность "исправить" число, ведь оно с легкостью может выйти за границы при вычитании.

Время работы алгоритма в _лучшем случае_ - **O(N)**, в _худшем_ опять же, около **O(N*M)**, но худший случай возникает лишь из-за хеша, допускающего большое количество коллизий. Тот же полиномиальный хеш с большой долей вероятности гарантирует, что такого не случится.

Блок-схема алгоритма:

![Блок-схема алгоритма](https://raw.githubusercontent.com/mocurin/test/master/pics/RK_Algorithm.svg?sanitize=true)

Хеширование строки:

![Хеширование строки](https://raw.githubusercontent.com/mocurin/test/master/pics/String%20hash.svg?sanitize=true)

Вычисление степени:

![Вычисление степени](https://raw.githubusercontent.com/mocurin/test/master/pics/Count%20biggest%20power.svg?sanitize=true)

Рехеширование:

![Рехеширование](https://raw.githubusercontent.com/mocurin/test/master/pics/Rehash.svg?sanitize=true)

Плюсы:
 - При правильном выборе хеш-функции время работы стремится к O(N)
 - Согласно википедии, отлично подходит для нахождении _множества_ образцов в тексте, позволяя находить их за O(N + K), где K - количество образцов, вместо O(N*K) у других. Он может уступать алгоритму Ахо-Корасик в худшем случае, но его, по идее, куда проще реализовать.

Минусы:
  - Подсчет хеша - в частности взятие по модулю в нем - очень громоздкая и медленная операция, а посему работает он медленнее того же КМП.
 
## Алгоритм Кнута-Морриса-Пратта
 
 Алгоритм, смысл которого заключается в правильной предобработке подстроки и создании особого массива, который будет использоваться как указание на какие позиции нужно возвращаться, в случае расхождения подстроки и строки, что полностью исключает какие-либо повторные проверки позиций.
 
В предобработке подстроки создается массив такой же длины как и подстрока, в каждый элемент которого последовательно заносится длина наибольших равных _префикса_ и _суффикса_ подстроки до этой позиции, включая ее. Затем, при сравнении подстроки со строкой, натыкаясь во время проверки подстроки можно будет откатиться не как в прямом алгоритме - к самому началу, а к определенной позиции, так как мы знаем сколько символов нужно пропустить.

Блок-схема алгоритма:

![Блок-схема алгоритма](https://raw.githubusercontent.com/mocurin/test/master/pics/KMP_algorithm.svg?sanitize=true)

Функция предобработки строки:

![Функция предобработки подстроки](https://raw.githubusercontent.com/mocurin/test/master/pics/Prefix%20function.svg?sanitize=true)

Время работы алгоритма что в _лучшем_, что в _худшем_ случаях - **O(N+M)**, то есть: обработка подстроки + обработка строки.

Плюсы:

 - Простота написания
 - Считается одним из самых быстрых алгоритмов из-за своей маленькой функции предобработки

Минусы:

- Выделение памяти в размере длины подстроки. Это не критично до определенного момента, но это все еще выделение памяти

## Графики
Первые два графика - 1000 повторений на строке длины от 16 до 8192 с подстрокой случайной длины

![Графики 1, 2](https://github.com/mocurin/lab_02_report/blob/master/pics/defined_substr.png?raw=true)

Библиотечный поиск работает на ура, показывая почти одинаковую (особенно в сравнении с моими алгоритмами) скорость работы, РК, видимо из-за тяжелой предобработки, работает медленнее КМП, но его скорость остается одинаковой на обоих типах строк. Прямой алгоритм очень хорош на простой строке, но невероятно плох на сложной - плох настолько, что мне пришлось обрезать несколько его последних результатов. Так же он хорошо держится из-за полного отсутствия предобработки. КМП просто хорош. Может и не библиотечный поиск, но результаты на обоих типах строк приблизительно на одном уровне при легкой предобработке.

Эти же гафики - 1000 повторений на строке длины 1000 с подстрокой от 10 до 999

![Графики 3, 4](https://github.com/mocurin/lab_02_report/blob/master/pics/rnd_susbtr.png?raw=true)

От размера подстрок алгоритмы зависят, но не то что бы очень сильно. Почти все они на этом графике - просто отдаленное прямые линии. Касаемо прямого - время растет до определенного размера подстроки, а затем резко падает. Случается это из-за того, что просто уменьшается количество перепроверок. В моих результатах пик выпал на 2/3 - 3/4 строки.

## Заключение
 В заключение хочется отметить, что все алгоритмы безусловно имеют право на жизнь (ну, может, кроме прямого. Учитывая то, как пишется КМП - уж точно), и знать стоит все.
